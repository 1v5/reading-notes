[上一章](./第2章.md)

# 使用函数

## 第18条 理解函数调用、方法调用及构造函数调用之间的不同
- 方法调用的上下文是调用该方法的对象
- 函数调用的上下文是全局对象(严格模式下是undefined)
- 构造函数需要通过new运算符调用，并产生一个新的对象作为其上下文

## 第19条 熟练掌握高阶函数
-  将函数作为参数或返回值的函数叫作高阶函数

## 第20条 使用call方法自定义接收者来调用方法
- call方法可以调用在给定的对象中不存在的方法

## 第21条 使用apply方法通过不同数量的参数调用函数
- 使用apply方法指定一个可计算的参数数组来调用可变参数的函数
  ```js
  average(1, 2, 3);   //2
  average.apply(null, [1, 2, 3]);   //2
  ```

## 第22条 使用arguments创建可变参数的函数
- 使用隐式的`arguments`对象实现可变参数的函数
  ```js
  function average() {
    for(var i = 0, sum = 0, len = arguments.leength; i < len; i++ ){
      sum += arguments[i];
    }
    return sum/len;
  }
  ```
- `apply`方法会降低可读性而且经常导致性能损失
- 考虑对可变参数的函数提供一个额外的固定元数的版本,从而使用者无需借助`apply`方法
  ```js
  // 固定元数函数
  function averageOfArray(arr) {
    for(var i = 0, sum = 0, len = arr.leength; i < len; i++ ){
      sum += arr[i];
    }
    return sum/len;
  }
  // 可变参数函数
  function average() {
    averageOfArray(arguments);
  }
  ```

## 第23条 永远不要修改arguments对象
- 修改`arguments`对象会影响到对应的函数的命名参数,严格模式下不支持对`arguments`对象取别名.
- 通过一开始复制参数中的元素到一个真正的数组的方式,避免修改`arguments`对象.
  ```js
  var args = [].slice.call(arguments);
  ```

## 第24条 使用变量保存`arguments`的引用
- 迭代器是一个可以顺序存取数据集合的对象
  ```js
  function values() {
    var args = arguments, len = args.length, i = 0;
    return {
      hasNext: function(){
        return i < len;
      },
      next: function(){
        if(this.hasNext()){
          return args[i++];
        }else{
          throw new Error("have no next!");
        }
      }
    };
  }
  // test
  var iter = values(1, 3, 5, 7, 9, 11);
  iter.next();  //1
  iter.next();  //3
  iter.next();  //5
  ```

<!-- ## 第25条 使用bind方法提取具有确定接收者的方法

## 第26条 使用bind方法实现函数柯里化

## 第27条 使用闭包而不是字符串来封装代码

## 第28条 不要信赖对象的toString方法

## 第29条 避免使用非标准的栈检查属性 -->

<!-- [下一章](./第4章.md) -->
